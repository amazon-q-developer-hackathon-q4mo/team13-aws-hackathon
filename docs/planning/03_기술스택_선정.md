# LiveInsight 기술스택 선정

## 해커톤 제약사항
- **기간**: 24시간
- **팀 구성**: 백엔드 개발자 2명
- **목표**: 동작하는 MVP 완성

## 기술스택 개요

### 백엔드 (Python 기반)
```
언어: Python 3.11
프레임워크: FastAPI (Lambda 호환)
배포: Terraform
테스트: pytest (최소한)
```

### 프론트엔드 (HTMX 기반)
```
기본: HTML5 + CSS3
인터랙션: HTMX 1.9
스타일링: Tailwind CSS (CDN)
차트: Chart.js (CDN)
```

### AWS 인프라
```
컴퓨팅: AWS Lambda
API: API Gateway (REST)
데이터베이스: DynamoDB
스토리지: S3 + CloudFront
배포: Terraform
```

## 상세 기술스택

### 1. 백엔드 스택

#### Python 라이브러리
```python
# requirements.txt (핵심만)
fastapi==0.104.1
mangum==0.17.0          # Lambda ASGI adapter
boto3==1.34.0           # AWS SDK
pydantic==2.5.0         # 데이터 검증
python-jose==3.3.0      # JWT 처리
uvicorn==0.24.0         # 로컬 개발용
```

#### 프로젝트 구조
```
liveinsight/
├── src/                      # Python 소스코드
│   ├── handlers/
│   │   ├── event_collector.py    # 이벤트 수집
│   │   ├── realtime_api.py       # 실시간 API
│   │   └── stats_api.py          # 통계 API
│   ├── models/
│   │   ├── events.py             # 이벤트 모델
│   │   └── sessions.py           # 세션 모델
│   ├── services/
│   │   ├── dynamodb.py           # DB 서비스
│   │   └── analytics.py          # 분석 로직
│   └── utils/
│       ├── response.py           # 응답 헬퍼
│       └── validation.py         # 검증 로직
├── terraform/                # 인프라 코드
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   ├── lambda.tf
│   ├── dynamodb.tf
│   └── api_gateway.tf
├── static/                   # 정적 파일
│   ├── dashboard.html
│   ├── liveinsight.js
│   └── styles.css
└── scripts/
    ├── build.sh
    └── deploy.sh
```

#### FastAPI 설정 (Lambda 최적화)
```python
from fastapi import FastAPI
from mangum import Mangum

app = FastAPI(
    title="LiveInsight API",
    version="1.0.0",
    docs_url=None,  # 프로덕션에서 비활성화
    redoc_url=None
)

# Lambda handler
handler = Mangum(app)
```

### 2. 프론트엔드 스택

#### HTMX 기반 대시보드
```html
<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/htmx.org@1.9.8"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <!-- HTMX로 동적 업데이트 -->
    <div hx-get="/api/realtime" hx-trigger="every 3s">
        Loading...
    </div>
</body>
</html>
```

#### 추적 스크립트 (Vanilla JS)
```javascript
// liveinsight.js (최소 구현)
(function() {
    const API_ENDPOINT = 'https://api.liveinsight.io/events';
    const API_KEY = document.currentScript.dataset.apiKey;
    
    // 이벤트 배치 전송
    const events = [];
    const sendEvents = () => {
        if (events.length === 0) return;
        fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'X-API-Key': API_KEY },
            body: JSON.stringify({ events: events.splice(0) })
        });
    };
    
    // 페이지뷰 추적
    events.push({
        type: 'page_view',
        url: location.href,
        timestamp: Date.now()
    });
    
    setInterval(sendEvents, 5000);
})();
```

### 3. AWS 인프라 스택 (Terraform)

#### Terraform 구조
```hcl
# terraform/main.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

# terraform/variables.tf
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "ap-northeast-2"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}

variable "project_name" {
  description = "Project name"
  type        = string
  default     = "liveinsight"
}
```

#### Lambda 함수 정의
```hcl
# terraform/lambda.tf
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "../src"
  output_path = "lambda_function.zip"
}

resource "aws_lambda_function" "event_collector" {
  filename         = "lambda_function.zip"
  function_name    = "${var.project_name}-event-collector-${var.environment}"
  role            = aws_iam_role.lambda_role.arn
  handler         = "handlers.event_collector.handler"
  runtime         = "python3.11"
  timeout         = 30
  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  environment {
    variables = {
      EVENTS_TABLE   = aws_dynamodb_table.events.name
      SESSIONS_TABLE = aws_dynamodb_table.sessions.name
    }
  }
}
```

#### DynamoDB 테이블
```hcl
# terraform/dynamodb.tf
resource "aws_dynamodb_table" "events" {
  name           = "${var.project_name}-events-${var.environment}"
  billing_mode   = "ON_DEMAND"
  hash_key       = "session_id"
  range_key      = "timestamp"

  attribute {
    name = "session_id"
    type = "S"
  }

  attribute {
    name = "timestamp"
    type = "N"
  }

  ttl {
    attribute_name = "ttl"
    enabled        = true
  }

  tags = {
    Name        = "${var.project_name}-events"
    Environment = var.environment
  }
}
```

#### DynamoDB 모델 (Pydantic)
```python
from pydantic import BaseModel
from typing import Optional
import time

class Event(BaseModel):
    session_id: str
    timestamp: int
    event_type: str
    page_url: str
    user_agent: Optional[str] = None
    referrer: Optional[str] = None
    ttl: int = int(time.time()) + 86400  # 24시간 후 삭제

class Session(BaseModel):
    session_id: str
    start_time: int
    last_activity: int
    is_active: bool = True
    page_count: int = 0
```

### 4. 개발 도구

#### 로컬 개발 환경
```bash
# 로컬 DynamoDB
docker run -p 8000:8000 amazon/dynamodb-local

# Python 개발 서버 (FastAPI)
cd src && uvicorn handlers.event_collector:app --reload --port 8000

# 프론트엔드 서빙
cd static && python -m http.server 8080
```

#### 배포 스크립트
```bash
#!/bin/bash
# scripts/deploy.sh

set -e

echo "Building Lambda package..."
cd src
zip -r ../lambda_function.zip . -x "__pycache__/*" "*.pyc"
cd ..

echo "Deploying infrastructure..."
cd terraform
terraform init
terraform plan
terraform apply -auto-approve
cd ..

echo "Uploading static files..."
aws s3 sync ./static s3://$(terraform -chdir=terraform output -raw s3_bucket_name)

echo "Deployment complete!"
echo "API URL: $(terraform -chdir=terraform output -raw api_gateway_url)"
echo "Dashboard URL: $(terraform -chdir=terraform output -raw cloudfront_url)"
```

#### 빌드 스크립트
```bash
#!/bin/bash
# scripts/build.sh

set -e

echo "Installing Python dependencies..."
cd src
pip install -r requirements.txt -t .
cd ..

echo "Creating Lambda deployment package..."
cd src
zip -r ../lambda_function.zip . -x "__pycache__/*" "*.pyc" "requirements.txt"
cd ..

echo "Build complete!"
```

## 해커톤 최적화 전략

### 1. 빠른 개발을 위한 선택

#### Python + FastAPI 선택 이유
- **빠른 개발**: 간결한 문법, 자동 문서화
- **Lambda 호환**: Mangum으로 쉬운 배포
- **타입 안정성**: Pydantic으로 데이터 검증
- **팀 친숙도**: 백엔드 개발자 2명 모두 Python 경험

#### HTMX 선택 이유
- **학습 곡선**: React/Vue보다 빠른 습득
- **서버 중심**: 백엔드 개발자가 프론트엔드도 담당 가능
- **실시간 업데이트**: 폴링 기반 간단 구현
- **SEO 친화적**: 서버 렌더링

### 2. 24시간 개발 계획

#### Day 1 (0-8시간): 인프라 구축
```
담당자 A: Terraform 인프라 코드 + DynamoDB 설계
담당자 B: FastAPI 기본 구조 + 모델 정의
```

#### Day 1 (8-16시간): 핵심 기능
```
담당자 A: 이벤트 수집 API + 추적 스크립트
담당자 B: 실시간 API + 기본 대시보드
```

#### Day 1 (16-24시간): 통합 및 배포
```
공동 작업: 통합 테스트 + 배포 + 데모 준비
```

### 3. 최소 기능 정의 (MVP)

#### 필수 기능 (24시간 내 완성)
- [x] 이벤트 수집 API
- [x] 추적 스크립트 (페이지뷰만)
- [x] 실시간 접속자 수
- [x] 기본 대시보드 (HTMX)
- [x] AWS 배포

#### 선택 기능 (시간 여유시)
- [ ] 세션 추적
- [ ] 페이지별 통계
- [ ] 차트 시각화
- [ ] 에러 처리 강화

### 4. 라이브러리 최소화

#### CDN 활용 (빌드 시간 단축)
```html
<!-- 외부 CDN 사용으로 빌드 과정 생략 -->
<script src="https://unpkg.com/htmx.org@1.9.8"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
```

#### Python 의존성 최소화
```python
# 핵심 라이브러리만 사용
fastapi      # API 프레임워크
mangum       # Lambda 어댑터
boto3        # AWS SDK
pydantic     # 데이터 검증
```

## 성능 고려사항

### 1. Lambda 최적화
```python
# 글로벌 변수로 연결 재사용
import boto3

dynamodb = boto3.resource('dynamodb')
events_table = dynamodb.Table(os.environ['EVENTS_TABLE'])

def handler(event, context):
    # 연결 재사용으로 콜드 스타트 최소화
    pass
```

### 2. DynamoDB 최적화
```python
# 배치 쓰기로 비용 절약
with events_table.batch_writer() as batch:
    for event in events:
        batch.put_item(Item=event.dict())
```

### 3. 프론트엔드 최적화
```javascript
// 이벤트 배치 처리
const eventQueue = [];
const flushEvents = () => {
    if (eventQueue.length > 0) {
        sendBatch(eventQueue.splice(0));
    }
};
setInterval(flushEvents, 5000);
```

## 테스트 전략 (최소한)

### 1. 단위 테스트
```python
# tests/test_events.py
def test_event_validation():
    event = Event(
        session_id="test",
        timestamp=1234567890,
        event_type="page_view",
        page_url="https://example.com"
    )
    assert event.session_id == "test"
```

### 2. 통합 테스트
```python
# tests/test_api.py
def test_event_collection():
    response = client.post("/events", json={
        "events": [{"type": "page_view", "url": "test"}]
    })
    assert response.status_code == 200
```

### 3. 수동 테스트
```bash
# API 테스트
curl -X POST https://api.liveinsight.io/events \
  -H "Content-Type: application/json" \
  -d '{"events":[{"type":"page_view","url":"test"}]}'

# 대시보드 테스트
open https://dashboard.liveinsight.io
```

## 배포 및 모니터링

### 1. 배포 파이프라인
```bash
# 원클릭 배포
./scripts/deploy.sh

# 배포 확인
aws logs tail /aws/lambda/liveinsight-event-collector-dev --follow
```

### Terraform 출력값
```hcl
# terraform/outputs.tf
output "api_gateway_url" {
  description = "API Gateway URL"
  value       = aws_api_gateway_deployment.liveinsight_deployment.invoke_url
}

output "s3_bucket_name" {
  description = "S3 bucket for static files"
  value       = aws_s3_bucket.static_files.bucket
}

output "cloudfront_url" {
  description = "CloudFront distribution URL"
  value       = aws_cloudfront_distribution.static_files.domain_name
}
```

### 2. 기본 모니터링
```hcl
# terraform/monitoring.tf
resource "aws_cloudwatch_metric_alarm" "lambda_errors" {
  alarm_name          = "${var.project_name}-lambda-errors-${var.environment}"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "Errors"
  namespace           = "AWS/Lambda"
  period              = "300"
  statistic           = "Sum"
  threshold           = "5"
  alarm_description   = "This metric monitors lambda errors"
}
```

### 3. 로그 모니터링
```python
import logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def handler(event, context):
    logger.info(f"Processing {len(events)} events")
```

## 위험 요소 및 대응

### 1. 시간 부족 위험
**대응**: 기능 우선순위 명확화, 페어 프로그래밍

### 2. AWS 배포 이슈
**대응**: 로컬 개발 환경 우선 구축, Terraform plan으로 사전 검증

### 3. HTMX 학습 곡선
**대응**: 간단한 예제부터 시작, 공식 문서 활용

### 4. DynamoDB 설계 실수
**대응**: 단순한 키 구조, 필요시 GSI 추가

### 5. S3 버킷 보안 위험
**대응**: 조직별 고유 접두사 사용, 버킷 즉시 생성, 소유권 확인

이 기술스택으로 24시간 내에 동작하는 LiveInsight MVP를 완성할 수 있습니다!